"""
Adapter for fetching burn calculation data from external sources.

This module provides interfaces and implementations for fetching the data needed
to calculate burn percentage:
- Emission amount in TAO (from chain/subtensor)
- TAO/USD price (from price oracle API)
- Total sales in USD (from sales_emission_ratio API)
- Sales-to-emission ratio target (from sales_emission_ratio API)

The sales_emission_ratio is expected to be returned from an external API that
tracks the target profitability ratio for miners. This ratio determines how
much miners should earn relative to the sales they generate.

TODO: Implement actual API calls in ValidatorBurnDataSource methods:
- _fetch_emission_in_tao(): Calculate total TAO emissions for the subnet over the period
- _fetch_tao_price_usd(): âœ… Implemented - fetches from https://mainnet.scantensor.opentensor.ai/price
- _fetch_total_sales_usd(): Fetch from sales_emission_ratio API
- _fetch_sales_emission_ratio(): Fetch from sales_emission_ratio API
"""
from abc import ABC, abstractmethod
from datetime import timedelta
from typing import Callable, Optional, Tuple
from dataclasses import dataclass
import requests
from bittensor.utils.btlogging import logging
import bittensor as bt

from core.constants import MINER_EMISSION_PERCENT

@dataclass
class BurnCalculationData:
    """Data required for burn percentage calculation."""
    emission_in_tao: float  # Total emission amount in TAO for the period
    tao_price_usd: float  # TAO price in USD
    total_sales_usd: float  # Total sales generated by miners in USD
    sales_emission_ratio: float  # Target ratio of sales to emissions (e.g., 1.0 for 1:1)


class IBurnDataSource(ABC):
    """Interface for fetching burn calculation data."""
    
    @abstractmethod
    def get_burn_data(self, scope: str) -> Optional[BurnCalculationData]:
        """
        Get burn calculation data for a given scope.
        
        Args:
            scope: Scope identifier (e.g., "network", "campaign:123")
        
        Returns:
            BurnCalculationData if available, None otherwise
        """
        pass


class ValidatorBurnDataSource(IBurnDataSource):
    """
    Burn data source implementation.
    
    TODO: Implement actual API calls to fetch:
    - Emission amount in TAO (from chain/subtensor)
    - TAO/USD price (from price oracle API)
    - Total sales in USD (from sales_emission_ratio API)
    - Sales-to-emission ratio (from sales_emission_ratio API)
    """
    
    def __init__(
        self,
        subtensor: bt.Subtensor,
        netuid: int,
        window_days_getter: Callable[[str], int],
        sales_emission_ratio_getter: Callable[[str], Optional[float]],
    ):
        """
        Initialize burn data source.
        
        Args:
            subtensor: Bittensor subtensor object for querying emission data
            netuid: Subnet UID
            window_days_getter: Callable that takes scope and returns window size in days
            sales_emission_ratio_getter: Callable that takes scope and returns sales_emission_ratio
        """
        self.subtensor = subtensor
        self.netuid = netuid
        self.window_days_getter = window_days_getter
        self.sales_emission_ratio_getter = sales_emission_ratio_getter
        
    def get_burn_data(self, scope: str) -> Optional[BurnCalculationData]:
        """
        Get burn calculation data for a given scope.
        
        Fetches all required data and returns a BurnCalculationData object if all
        data is available, None otherwise.
        
        Args:
            scope: Scope identifier
        
        Returns:
            BurnCalculationData if all data is available, None otherwise
        """
        emission_in_tao = self._fetch_emission_in_tao(scope)
        tao_price_usd = self._fetch_tao_price_usd()
        total_sales_usd = self._fetch_total_sales_usd(scope)
        sales_emission_ratio = self._fetch_sales_emission_ratio(scope)

        # Return None if any required data is missing
        if any(x is None for x in [emission_in_tao, tao_price_usd, total_sales_usd, sales_emission_ratio]):
            return None

        return BurnCalculationData(
            emission_in_tao=emission_in_tao.tao,
            tao_price_usd=tao_price_usd,
            total_sales_usd=total_sales_usd,
            sales_emission_ratio=sales_emission_ratio,
        )

    
    def _fetch_emission_in_tao(self, scope: str) -> Optional[bt.Balance]:
        """
        Fetch total emission amount in TAO for the period.
        
        Queries blockEmission from the SubtensorModule storage.
        Note: This returns the per-block emission. To get total emissions for a period,
        you would need to multiply by the number of blocks in that period.
        
        Args:
            scope: Scope identifier
        
        Returns:
            Emission amount in TAO per block, or None if unavailable
        """
        try:
            subnet_tao_in_emission = self.subtensor.query_subtensor("SubnetTaoInEmission", params=[self.netuid])

            if subnet_tao_in_emission is None:
                logging.warning("Failed to fetch SubnetTaoInEmission from subtensor")
                return None

            subnet_tao_in_emission_value = subnet_tao_in_emission.value if hasattr(subnet_tao_in_emission, 'value') else subnet_tao_in_emission

            if not isinstance(subnet_tao_in_emission_value, (int, float)) or subnet_tao_in_emission_value <= 0:
                logging.warning(f"Invalid SubnetTaoInEmission value: {subnet_tao_in_emission_value}")
                return None

            window_days = self.window_days_getter(scope)

            block_window = timedelta(days=window_days).total_seconds() // bt.BLOCKTIME

            subnet_tao_in_emission_value = int(subnet_tao_in_emission_value * block_window * MINER_EMISSION_PERCENT)

            subnet_tao_in_emission_value = bt.Balance.from_rao(subnet_tao_in_emission_value)

            logging.info(f"Fetched SubnetTaoInEmission: {subnet_tao_in_emission_value} for {window_days} days")
            return subnet_tao_in_emission_value
            
        except Exception as e:
            logging.warning(f"Failed to fetch BlockEmission from subtensor: {e}")
            return None
    
    def _fetch_tao_price_usd(self) -> Optional[float]:
        """
        Fetch TAO/USD price from price oracle.
        
        Fetches from https://mainnet.scantensor.opentensor.ai/price
        
        Returns:
            TAO price in USD, or None if unavailable
        """
        try:
            url = "https://mainnet.scantensor.opentensor.ai/price"
            response = requests.get(url, timeout=10)
            response.raise_for_status()  # Raise an exception for bad status codes
            
            data = response.json()
            price = data.get("price")
            
            if price is None:
                logging.warning("TAO price API returned data without 'price' field")
                return None
            
            if not isinstance(price, (int, float)) or price <= 0:
                logging.warning(f"Invalid TAO price value: {price}")
                return None
            
            logging.info(f"Fetched TAO price: ${price:.2f} USD")
            return float(price)
            
        except requests.exceptions.RequestException as e:
            logging.warning(f"Failed to fetch TAO price from API: {e}")
            return None
        except (ValueError, KeyError, TypeError) as e:
            logging.warning(f"Failed to parse TAO price API response: {e}")
            return None
    
    def _fetch_total_sales_usd(self, scope: str) -> Optional[float]:
        """
        Fetch total sales in USD from sales_emission_ratio API.
        
        TODO: Implement fetching from external API that tracks miner sales.
        This should return the total USD value of sales generated by miners
        over the relevant time period.
        
        Args:
            scope: Scope identifier
        
        Returns:
            Total sales in USD, or None if unavailable
        """
        # TODO: Implement
        return 10000.0
    
    def _fetch_sales_emission_ratio(self, scope: str) -> Optional[float]:
        """
        Fetch sales-to-emission ratio target from external source.
        
        Uses the sales_emission_ratio_getter to fetch from external API.
        
        Args:
            scope: Scope identifier
        
        Returns:
            Sales-to-emission ratio, or None if unavailable
        """
        return self.sales_emission_ratio_getter(scope)

