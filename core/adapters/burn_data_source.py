"""
Adapter for fetching burn calculation data from external sources.

This module provides interfaces and implementations for fetching the data needed
to calculate burn percentage:
- Emission amount in TAO (from chain/subtensor)
- TAO/USD price (from price oracle API)
- Total sales in USD (from sales_emission_ratio API)
- Sales-to-emission ratio target (from sales_emission_ratio API)

The sales_emission_ratio is expected to be returned from an external API that
tracks the target profitability ratio for miners. This ratio determines how
much miners should earn relative to the sales they generate.

TODO: Implement actual API calls in ValidatorBurnDataSource methods:
- _fetch_emission_in_tao(): Calculate total TAO emissions for the subnet over the period
- _fetch_tao_price_usd(): âœ… Implemented - fetches from https://mainnet.scantensor.opentensor.ai/price
- _fetch_total_sales_usd(): Fetch from sales_emission_ratio API
- _fetch_sales_emission_ratio(): Fetch from sales_emission_ratio API
"""
from abc import ABC, abstractmethod
from datetime import timedelta
from typing import Callable, Optional, Tuple
from dataclasses import dataclass
import requests
from bittensor.utils.btlogging import logging
import bittensor as bt
import os


from core.constants import MINER_EMISSION_PERCENT, NETWORK_BASE_URLS

@dataclass
class BurnCalculationData:
    """Data required for burn percentage calculation."""
    emission_in_tao: float  # Total emission amount in TAO for the period
    tao_price_usd: float  # TAO price in USD
    total_sales_usd: float  # Total sales generated by miners in USD
    sales_emission_ratio: float  # Target ratio of sales to emissions (e.g., 1.0 for 1:1)


class IBurnDataSource(ABC):
    """Interface for fetching burn calculation data."""
    
    @abstractmethod
    def get_burn_data(self, scope: str, miner_stats_scope: str = None) -> Optional[BurnCalculationData]:
        """
        Get burn calculation data for a given scope.
        
        Args:
            scope: Scope identifier for config (e.g., "mech0", "mech1")
            miner_stats_scope: Scope identifier for fetching miner stats (e.g., campaign_id).
                              If not provided, uses scope.
        
        Returns:
            BurnCalculationData if available, None otherwise
        """
        pass


class ValidatorBurnDataSource(IBurnDataSource):
    """
    Burn data source implementation.
    
    TODO: Implement actual API calls to fetch:
    - Emission amount in TAO (from chain/subtensor)
    - TAO/USD price (from price oracle API)
    - Total sales in USD (from sales_emission_ratio API)
    - Sales-to-emission ratio (from sales_emission_ratio API)
    """
    
    def __init__(
        self,
        subtensor: bt.Subtensor,
        netuid: int,
        window_days_getter: Callable[[str], int],
        sales_emission_ratio_getter: Callable[[str], Optional[float]],
        miner_stats_source,
    ):
        """
        Initialize burn data source.
        
        Args:
            subtensor: Bittensor subtensor object for querying emission data
            netuid: Subnet UID
            window_days_getter: Callable that takes scope and returns window size in days
            sales_emission_ratio_getter: Callable that takes scope and returns sales_emission_ratio
            miner_stats_source: Miner stats provider injected from validator (implements IMinerStatsSource)
        """
        self.subtensor = subtensor
        self.netuid = netuid
        self.window_days_getter = window_days_getter
        self.sales_emission_ratio_getter = sales_emission_ratio_getter
        self.miner_stats_source = miner_stats_source
        
    def get_burn_data(self, scope: str, miner_stats_scope: str = None) -> Optional[BurnCalculationData]:
        """
        Get burn calculation data for a given scope.
        
        Fetches all required data and returns a BurnCalculationData object if all
        data is available, None otherwise.
        
        Args:
            scope: Scope identifier for config (e.g., "mech0", "mech1")
            miner_stats_scope: Scope identifier for fetching miner stats (e.g., campaign_id).
                              If not provided, uses scope.
        
        Returns:
            BurnCalculationData if all data is available, None otherwise
        """
        # Use campaign scope for miner stats, fallback to scope if not provided
        stats_scope = miner_stats_scope if miner_stats_scope is not None else scope
        
        emission_in_tao = self._fetch_emission_in_tao(scope)
        tao_price_usd = self._fetch_tao_price_usd()
        total_sales_usd = self._fetch_total_sales_usd(stats_scope)
        sales_emission_ratio = self._fetch_sales_emission_ratio(scope)

        # Return None if any required data is missing
        if any(x is None for x in [emission_in_tao, tao_price_usd, total_sales_usd, sales_emission_ratio]):
            return None

        return BurnCalculationData(
            emission_in_tao=emission_in_tao.tao,
            tao_price_usd=tao_price_usd,
            total_sales_usd=total_sales_usd,
            sales_emission_ratio=sales_emission_ratio,
        )

    
    def _fetch_emission_in_tao(self, scope: str) -> Optional[bt.Balance]:
        """
        Fetch total emission amount in TAO for the period.
        
        Queries blockEmission from the SubtensorModule storage.
        Note: This returns the per-block emission. To get total emissions for a period,
        you would need to multiply by the number of blocks in that period.
        
        Args:
            scope: Scope identifier
        
        Returns:
            Emission amount in TAO per block, or None if unavailable
        """
        try:
            subnet_tao_in_emission = self.subtensor.query_subtensor("SubnetTaoInEmission", params=[self.netuid])

            if subnet_tao_in_emission is None:
                logging.warning("Failed to fetch SubnetTaoInEmission from subtensor")
                return None

            subnet_tao_in_emission_value = subnet_tao_in_emission.value if hasattr(subnet_tao_in_emission, 'value') else subnet_tao_in_emission

            if not isinstance(subnet_tao_in_emission_value, (int, float)) or subnet_tao_in_emission_value < 0:
                logging.warning(f"Invalid SubnetTaoInEmission value: {subnet_tao_in_emission_value}")
                return None

            window_days = self.window_days_getter(scope)

            block_window = timedelta(days=window_days).total_seconds() // bt.BLOCKTIME

            subnet_tao_in_emission_value = int(subnet_tao_in_emission_value * block_window * MINER_EMISSION_PERCENT)

            subnet_tao_in_emission_value = bt.Balance.from_rao(subnet_tao_in_emission_value)

            logging.info(f"Fetched SubnetTaoInEmission: {subnet_tao_in_emission_value} for {window_days} days")
            return subnet_tao_in_emission_value
            
        except Exception as e:
            logging.warning(f"Failed to fetch BlockEmission from subtensor: {e}")
            return None
    
    def _fetch_tao_price_usd(self) -> Optional[float]:
        """
        Fetch TAO/USD price from price oracle.
        
        Fetches from https://mainnet.scantensor.opentensor.ai/price
        
        Returns:
            TAO price in USD, or None if unavailable
        """
        try:
            url = "https://mainnet.scantensor.opentensor.ai/price"
            response = requests.get(url, timeout=10)
            response.raise_for_status()  # Raise an exception for bad status codes
            
            data = response.json()
            price = data.get("price")
            
            if price is None:
                logging.warning("TAO price API returned data without 'price' field")
                return None
            
            if not isinstance(price, (int, float)) or price <= 0:
                logging.warning(f"Invalid TAO price value: {price}")
                return None
            
            logging.info(f"Fetched TAO price: ${price:.2f} USD")
            return float(price)
            
        except requests.exceptions.RequestException as e:
            logging.warning(f"Failed to fetch TAO price from API: {e}")
            return None
        except (ValueError, KeyError, TypeError) as e:
            logging.warning(f"Failed to parse TAO price API response: {e}")
            return None
    
    def _fetch_total_sales_usd(self, scope: str) -> Optional[float]:
        """
        Fetch total sales in USD from miner-stats API.
        
        Uses the injected miner_stats_source (from the validator) to fetch
        miner stats and derives total sales from that data, instead of
        calling an external HTTP API directly.
        
        Args:
            scope: Scope identifier
        
        Returns:
            Total sales in USD, or None if unavailable
        """
        try:
            # Get window_days for this scope to pass to the miner stats source
            window_days = self.window_days_getter(scope)
            
            # Fetch miner stats using the injected provider
            miner_stats_list = self.miner_stats_source.fetch_window(scope, window_days)
            if not miner_stats_list:
                logging.warning(f"No miner stats available to compute total_sales_usd for scope {scope}")
                return None
            
            # Derive total sales in USD from miner statistics.
            # We treat revenue_usd as the USD value of sales generated by miners.
            total_sales = sum(stats.revenue_usd for _, stats in miner_stats_list)
            
            logging.info(f"Computed total_sales_usd from miner stats: ${total_sales:.2f} for scope {scope}")
            return float(total_sales)
            
        except requests.exceptions.RequestException as e:
            logging.warning(f"Failed to compute total_sales_usd for scope {scope}: {e}")
            return None
        except (ValueError, KeyError, TypeError) as e:
            logging.warning(f"Failed to compute total_sales_usd from miner stats for scope {scope}: {e}")
            return None
    
    def _fetch_sales_emission_ratio(self, scope: str) -> Optional[float]:
        """
        Fetch sales-to-emission ratio target from external source.
        
        Uses the sales_emission_ratio_getter to fetch from external API.
        
        Args:
            scope: Scope identifier
        
        Returns:
            Sales-to-emission ratio, or None if unavailable
        """
        return self.sales_emission_ratio_getter(scope)

